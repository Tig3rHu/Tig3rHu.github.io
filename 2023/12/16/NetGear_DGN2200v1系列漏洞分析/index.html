<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/favicon.ico >
    <title>
        Tig3rHu&#39;s Blog
    </title>
    <meta name="description" content= Hello World >
    <meta name="keywords" content= HigerHu,vulnerability,security,cyber >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.0.0"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            NetGear__DNG2200v1系列漏洞分析
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="NetGear-DGN2200v1系列漏洞分析"><a href="#NetGear-DGN2200v1系列漏洞分析" class="headerlink" title="NetGear DGN2200v1系列漏洞分析"></a>NetGear DGN2200v1系列漏洞分析</h1><h3 id="获取和解压固件"><a href="#获取和解压固件" class="headerlink" title="获取和解压固件"></a>获取和解压固件</h3><p>固件可从供应商的网站上获得，这使我们更容易获得副本进行检查。它是一个简单的 .zip 文件，包含发行说明 (.html) 和固件映像本身（.chk 文件）。在 .chk 文件上运行binwalk最终提取了文件系统 ( squash-fs )。</p>
<p><img src="/NetGear2200v1%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.assets/image1.png" alt="image-20231216202735932"></p>
<p>由器固件文件系统本身是一个标准的 Linux 根文件系统，并添加了一些小功能。我们关心和研究有以下几点</p>
<ul>
<li>&#x2F;www  –  包含html页面和.gif图片</li>
<li>&#x2F;usr&#x2F;sbin – 包含 NETGEAR 的各种自定义二进制文件，包括 HTTPd、FTPC 等</li>
</ul>
<p>由于我们看到异常通信使用 httpd 服务的标准端口，因此我们将重点放在 httpd 上。httpd 本身是一个 32 位大端 MIPS ELF，针对 uClibc (嵌入式设备的标准 libc）编译，似乎整个服务器端逻辑 (CGI) 都被编译到 httpd 中。</p>
<p><img src="/NetGear2200v1%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.assets/image2.png" alt="image-20231216202735932"></p>
<h3 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h3><p>在探索嵌入式web服务时，首先要考虑以下几个问题</p>
<ol>
<li>Web 服务是否显示一些未经身份验证的页面？如果是这样，他们是如何治理的？</li>
<li>Web 服务如何执行身份验证？</li>
<li>Web服务是否正确处理请求（即是否存在内存损坏错误）？</li>
<li>Web 服务是否实施了某些安全措施，例如（反）跨站点请求伪造令牌或内容安全策略？</li>
</ol>
<p>为了回答这些问题，我们对 httpd 二进制文件进行了静态分析，并通过运行 QEMU（一个开源模拟器）对固件进行仿真模拟，另外使用了hook（例如 NVRAM getter 和 setter）进行了一些动态分析。</p>
<h3 id="DGN-2200V1路由器中存在的漏洞"><a href="#DGN-2200V1路由器中存在的漏洞" class="headerlink" title="DGN 2200V1路由器中存在的漏洞"></a>DGN 2200V1路由器中存在的漏洞</h3><h4 id="绕过身份验证访问路由器管理界面"><a href="#绕过身份验证访问路由器管理界面" class="headerlink" title="绕过身份验证访问路由器管理界面"></a>绕过身份验证访问路由器管理界面</h4><p>在检查 httpd 如何规定哪些页面应该在没有身份验证的情况下提供时，我们发现了以下伪代码：</p>
<p><img src="/NetGear2200v1%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.assets/image3.png" alt="image-20231216202735932"></p>
<p>这些代码是httpd中的第一个页面处理代码，它会自动允许一些页面，例如form.css或者func.js，正常来说，这些设置并没有问题，但是异常点在于NetGear使用strstr函数来检查是否有“.jpg”“.gif”或者“ess_“字符串，用来匹配整个 url 。<br>因此我们可以使用GET 方式在URL中带有strstr检查的字符串（如 “?.gif” ）来访问设备的任意界面，其中包括身份验证的界面，使用如下</p>
<p><code>https://ip/WAN_wan.htm?pic.gif</code></p>
<p>就可以成功绕过身份验证访问路由器管理界面了。</p>
<h4 id="通过加密侧信道攻击推断路由器凭证"><a href="#通过加密侧信道攻击推断路由器凭证" class="headerlink" title="通过加密侧信道攻击推断路由器凭证"></a>通过加密侧信道攻击推断路由器凭证</h4><p>在这个阶段，我们已经完全控制了路由器管理界面，但是我们继续研究身份验证本身是如何实现的。<br>我们注意到httpd 组件对http界面进行基础认证，需要将username和password 使用base64来进行编译，然后在http header中发送，最后在路由器内存中保存的用户名和密码进行验证，路由器将这些信息存储在NVRAM中。<br>在我们检查身份验证的过程中，我们发现了一种可以让攻击者获取正确凭据的旁道攻击：</p>
<p><img src="/NetGear2200v1%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.assets/image4.png" alt="image-20231216202735932"></p>
<p>这里要注意，username 和 password 是使用strcmp来进行比较的，strcmp 在 libc 中的实现是通过逐个字符比较直到观察到 NUL 终止符或直到发生不匹配来工作。</p>
<p>攻击者可以通过测量失败所需的时间来利用后者。例如，在测量第一个字符的次数时，我们得到如下图：</p>
<p><img src="/NetGear2200v1%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.assets/image5.png" alt="image-20231216202735932"></p>
<p>这表示第一个字符是“n”。攻击者可以重复此过程（“na”、“nb”、“nc”等）以获取第二个字符，直到泄露整个用户名和密码。</p>
<p>我们向 NETGEAR 建议他们可以通过执行基于 XOR 的内存比较来避免此类攻击，例如：</p>
<p><img src="/NetGear2200v1%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.assets/image6.png" alt="image-20231216202735932"></p>
<p>使字节不匹配，该功能也会继续。类似的方法可以在加密安全库中看到，例如OpenSSL 的 CRYPTO_memcmp。</p>
<h4 id="检索存储在设备中的密钥"><a href="#检索存储在设备中的密钥" class="headerlink" title="检索存储在设备中的密钥"></a>检索存储在设备中的密钥</h4><p>当完成身份验证绕过漏洞之后，我们仍然想看看是否可以利用其他现有的漏洞来恢复路由器使用的username和密码，因为我们决定使用路由器的配置备份\恢复功能。<br>我们可以使用身份绕过获取文件：<br><code> hxxp://router_addr:8080/NETGEAR_DGN2200[.]cfg?pic[.]gif.</code><br>这个文件具有高熵，这表明它已被加密，我们无法直接读取内容，并且binwalk也没有任何结果。</p>
<p><img src="/NetGear2200v1%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.assets/image7.png" alt="image-20231216202735932"></p>
<p>当我们对“备份\恢复“的功能进行逆向后，我们的问题被解决了。</p>
<p><img src="/NetGear2200v1%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.assets/image8.png" alt="image-20231216202735932"></p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="Ex6100v2-固件分析"><a href="#Ex6100v2-固件分析" class="headerlink" title="Ex6100v2 固件分析"></a>Ex6100v2 固件分析</h4><p>看完这边漏洞分析文章之后，根据以往对Netgear固件分析中，发现这种情况存在许多版本的固件中，于是我翻出了实验室的NetGear Ex6100v2 路由设备，下载到对应版本的固件，然后对固件进行解包分析，<br>根据&#x2F;etc&#x2F;init.d&#x2F;rcS文件中的内容<br>找到uhttpd 的组件（<br>uHTTPd 是一个 OpenWrt&#x2F;LUCI 开发者从头编写的 Web 服务器），可以看到这个固件是使用NX的保护措施。</p>
<p><img src="/NetGear2200v1%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.assets/image9.png" alt="image-20231216202735932"></p>
<p>在我分析&#x2F;etc&#x2F;boot文件中，看到如下内容，也可以证明这是一个OpenWRT类型的web组件。</p>
<p><img src="/NetGear2200v1%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.assets/image10.png" alt="image-20231216202735932"></p>
<p>在uhttpd组件的逆向中，看到了如下的伪代码</p>
<p><img src="/NetGear2200v1%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.assets/image11.png" alt="image-20231216202735932"></p>
<p>本来以为这也是一个存在身份验证绕过的固件，但是继续查看引用，看到这个函数需要在用户认证之后才会触发</p>
<p><img src="/NetGear2200v1%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.assets/image12.png" alt="image-20231216202735932"></p>
<p>于是在经过实际的测试，确实是需要在经过认证才能访问（鸡肋）</p>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p><h4>Copyright © 2023 | Author: HigerHu | </a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">Page Views: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">Unique Visitors: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="">
<input type="hidden" id="valine_appKey" value="">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
